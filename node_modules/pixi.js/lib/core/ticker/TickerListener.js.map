{"version":3,"sources":["../../../src/core/ticker/TickerListener.js"],"names":["TickerListener","fn","context","priority","once","next","previous","_destroyed","match","emit","deltaTime","call","destroy","redirect","connect","hard"],"mappings":";;;;;;AAAA;;;;;;;IAOqBA,c;AAEjB;;;;;;;;AAQA,0BAAYC,EAAZ,EACA;AAAA,QADgBC,OAChB,uEAD0B,IAC1B;AAAA,QADgCC,QAChC,uEAD2C,CAC3C;AAAA,QAD8CC,IAC9C,uEADqD,KACrD;;AAAA;;AACI;;;;AAIA,SAAKH,EAAL,GAAUA,EAAV;;AAEA;;;;AAIA,SAAKC,OAAL,GAAeA,OAAf;;AAEA;;;;AAIA,SAAKC,QAAL,GAAgBA,QAAhB;;AAEA;;;;AAIA,SAAKC,IAAL,GAAYA,IAAZ;;AAEA;;;;AAIA,SAAKC,IAAL,GAAY,IAAZ;;AAEA;;;;AAIA,SAAKC,QAAL,GAAgB,IAAhB;;AAEA;;;;;AAKA,SAAKC,UAAL,GAAkB,KAAlB;AACH;;AAED;;;;;;;;;2BAOAC,K,kBAAMP,E,EAAIC,O,EACV;AACIA,cAAUA,WAAW,IAArB;;AAEA,WAAO,KAAKD,EAAL,KAAYA,EAAZ,IAAkB,KAAKC,OAAL,KAAiBA,OAA1C;AACH,G;;AAED;;;;;;;2BAKAO,I,iBAAKC,S,EACL;AACI,QAAI,KAAKR,OAAT,EACA;AACI,WAAKD,EAAL,CAAQU,IAAR,CAAa,KAAKT,OAAlB,EAA2BQ,SAA3B;AACH,KAHD,MAKA;AACI,WAAKT,EAAL,CAAQS,SAAR;AACH;;AAED,QAAI,KAAKN,IAAT,EACA;AACI,WAAKQ,OAAL;AACH;;AAED,QAAMC,WAAW,KAAKR,IAAtB;;AAEA;AACA;AACA,QAAI,KAAKE,UAAT,EACA;AACI,WAAKF,IAAL,GAAY,IAAZ;AACH;;AAED,WAAOQ,QAAP;AACH,G;;AAED;;;;;;2BAIAC,O,oBAAQR,Q,EACR;AACI,SAAKA,QAAL,GAAgBA,QAAhB;AACA,QAAIA,SAASD,IAAb,EACA;AACIC,eAASD,IAAT,CAAcC,QAAd,GAAyB,IAAzB;AACH;AACD,SAAKD,IAAL,GAAYC,SAASD,IAArB;AACAC,aAASD,IAAT,GAAgB,IAAhB;AACH,G;;AAED;;;;;;;;2BAMAO,O,sBACA;AAAA,QADQG,IACR,uEADe,KACf;;AACI,SAAKR,UAAL,GAAkB,IAAlB;AACA,SAAKN,EAAL,GAAU,IAAV;AACA,SAAKC,OAAL,GAAe,IAAf;;AAEA;AACA,QAAI,KAAKI,QAAT,EACA;AACI,WAAKA,QAAL,CAAcD,IAAd,GAAqB,KAAKA,IAA1B;AACH;;AAED,QAAI,KAAKA,IAAT,EACA;AACI,WAAKA,IAAL,CAAUC,QAAV,GAAqB,KAAKA,QAA1B;AACH;;AAED;AACA,QAAMO,WAAW,KAAKP,QAAtB;;AAEA;AACA,SAAKD,IAAL,GAAYU,OAAO,IAAP,GAAcF,QAA1B;AACA,SAAKP,QAAL,GAAgB,IAAhB;;AAEA,WAAOO,QAAP;AACH,G;;;;;kBArJgBb,c","file":"TickerListener.js","sourcesContent":["/**\n * Internal class for handling the priority sorting of ticker handlers.\n *\n * @private\n * @class\n * @memberof PIXI.ticker\n */\nexport default class TickerListener\n{\n    /**\n     * Constructor\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context=null] - The listener context\n     * @param {number} [priority=0] - The priority for emitting\n     * @param {boolean} [once=false] - If the handler should fire once\n     */\n    constructor(fn, context = null, priority = 0, once = false)\n    {\n        /**\n         * The handler function to execute.\n         * @member {Function}\n         */\n        this.fn = fn;\n\n        /**\n         * The calling to execute.\n         * @member {Function}\n         */\n        this.context = context;\n\n        /**\n         * The current priority.\n         * @member {number}\n         */\n        this.priority = priority;\n\n        /**\n         * If this should only execute once.\n         * @member {boolean}\n         */\n        this.once = once;\n\n        /**\n         * The next item in chain.\n         * @member {TickerListener}\n         */\n        this.next = null;\n\n        /**\n         * The previous item in chain.\n         * @member {TickerListener}\n         */\n        this.previous = null;\n\n        /**\n         * `true` if this listener has been destroyed already.\n         * @member {boolean}\n         * @private\n         */\n        this._destroyed = false;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} context - The listener context\n     * @return {boolean} `true` if the listener match the arguments\n     */\n    match(fn, context)\n    {\n        context = context || null;\n\n        return this.fn === fn && this.context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param {number} deltaTime - time since the last emit.\n     * @return {TickerListener} Next ticker\n     */\n    emit(deltaTime)\n    {\n        if (this.context)\n        {\n            this.fn.call(this.context, deltaTime);\n        }\n        else\n        {\n            this.fn(deltaTime);\n        }\n\n        if (this.once)\n        {\n            this.destroy();\n        }\n\n        const redirect = this.next;\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param {TickerListener} previous - Input node, previous listener\n     */\n    connect(previous)\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param {boolean} [hard = false] `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @return {TickerListener} The listener to redirect while emitting or removing.\n     */\n    destroy(hard = false)\n    {\n        this._destroyed = true;\n        this.fn = null;\n        this.context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.previous;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n"]}